/* eslint-disable */
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export type L1 = string;
export type L2 = string;
/**
 * An enumeration.
 */
export type SearchAlgorithms = 'weighted_levenstein' | 'liblevenstein_automata';
export type Insertioncost = number;
export type Deletioncost = number;
export type Insertionatbeginningcost = number;
export type Deletionatendcost = number;
export type Substitutioncostspath = string;
export type Defaultsubstitutioncost = number;
/**
 * An enumeration.
 */
export type StemmerEnum = 'snowball_english' | 'none';
export type Lower = boolean;
/**
 * An enumeration.
 */
export type NormalizationEnum = 'NFC' | 'NFD' | 'NFKC' | 'NKFD' | 'none';
export type RemovePunctuation = string;
export type ReplaceRules = {
  [k: string]: string;
}[];
export type Alphabet = string[];
export type OptionalFieldName = string;
export type Role = string;
export type Name = string;
export type Credits = Contributor[];
export type Build = string;
export type Word = string;
export type Definition = string;
export type Entryid = string;
export type SortingForm = number[];
export type Theme = string;
export type SecondaryTheme = string;
export type Img = string;
export type Description = string;
export type Filename = string;
export type Audio = Audio1[];
export type DefinitionAudio = Audio1[];
export type ExampleSentence = string[];
export type ExampleSentenceDefinition = string[];
export type ExampleSentenceAudio = Audio1[];
export type ExampleSentenceDefinitionAudio = Audio1[];
export type SortedData = DictionaryEntryExportFormat[];
export type Entryindex = string;
export type Positionindex = number;
export type Location = [Entryindex, Positionindex][];

export interface MTDExportFormat {
  config: LanguageConfigurationExportFormat;
  sorted_data: SortedData;
  l1_index: L1Index;
  l2_index: L2Index;
}
export interface LanguageConfigurationExportFormat {
  L1: L1;
  L2: L2;
  l1_search_strategy: SearchAlgorithms;
  l2_search_strategy: SearchAlgorithms;
  l1_search_config?: WeightedLevensteinConfig;
  l2_search_config?: WeightedLevensteinConfig;
  l1_stemmer: StemmerEnum;
  l2_stemmer: StemmerEnum;
  l1_normalization_transducer: RestrictedTransducer;
  l2_normalization_transducer: RestrictedTransducer;
  alphabet: Alphabet;
  optional_field_name: OptionalFieldName;
  credits?: Credits;
  build: Build;
  [k: string]: unknown;
}
export interface WeightedLevensteinConfig {
  insertionCost?: Insertioncost;
  deletionCost?: Deletioncost;
  insertionAtBeginningCost?: Insertionatbeginningcost;
  deletionAtEndCost?: Deletionatendcost;
  substitutionCosts?: Substitutioncosts;
  substitutionCostsPath?: Substitutioncostspath;
  defaultSubstitutionCost?: Defaultsubstitutioncost;
}
export interface Substitutioncosts {
  [k: string]: {
    [k: string]: number;
  };
}
export interface RestrictedTransducer {
  lower?: Lower;
  unicode_normalization?: NormalizationEnum & string;
  remove_punctuation?: RemovePunctuation;
  replace_rules?: ReplaceRules;
}
export interface Contributor {
  role: Role;
  name: Name;
}
/**
 * There is a DictionaryEntry created for each entry in your dictionary.
 * It intentionally shares the same data structure as the ParserTargets,
 * but allows for extra fields. This is the same as DictionaryEntry except with
 * some specifications for the output format (for example every exported entry will have)
 * a value for entryID, and a sorting_form).
 */
export interface DictionaryEntryExportFormat {
  word: Word;
  definition: Definition;
  entryID: Entryid;
  sorting_form: SortingForm;
  theme?: Theme;
  secondary_theme?: SecondaryTheme;
  img?: Img;
  audio?: Audio;
  definition_audio?: DefinitionAudio;
  example_sentence?: ExampleSentence;
  example_sentence_definition?: ExampleSentenceDefinition;
  example_sentence_audio?: ExampleSentenceAudio;
  example_sentence_definition_audio?: ExampleSentenceDefinitionAudio;
  optional?: Optional;
  [k: string]: unknown;
}
export interface Audio1 {
  description?: Description;
  filename: Filename;
}
export interface Optional {
  [k: string]: string;
}
export interface L1Index {
  [k: string]: {
    [k: string]: PostingData;
  };
}
export interface PostingData {
  location: Location;
  score: Score;
}
export interface Score {
  [k: string]: number;
}
export interface L2Index {
  [k: string]: {
    [k: string]: PostingData;
  };
}
